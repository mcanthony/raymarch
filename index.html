<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>shader</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <canvas id="board"></canvas>
  <script type="text/frag-shader" id="frag">
    #define max_distance 20.0
    #define epsilon 0.005
    #define max_steps 25
    #define FOV 75.0

    precision mediump float;
    uniform vec2 resolution;
    uniform float t;

    float sphere(vec3 p, float s){
      return length(p) - s;
    }

    float box(vec3 p, vec3 b) {
      return length(max(abs(p) - b, 0.0));
    }

    float smin( float a, float b, float k ) {
        float res = exp(-k * a) + exp(-k * b);
        return -log(res) / k;
    }

    vec3 rep( vec3 p, vec3 c ) {
      return mod(p, c) - 0.5 * c;
    }

    float scene(vec3 point) {
      vec3 p = rep(point, vec3(2,2,2));
      return smin(
        smin(sphere(p, 0.5), box(p, vec3(1.0, 0.01, 0.1)), 24.0),
        box(p, vec3(0.01, 1.0, 0.1)), 24.0);
    }

    float raymarch(vec3 ray_origin, vec3 ray_direction) {
      float d = 0.0;

      for (int i = 0; i < max_steps; i++) {
        vec3 new_point = ray_origin + ray_direction * d;
        float s = scene(new_point);
        if (s < epsilon) return d;
        d += s;
        if (d > max_distance) return max_distance;
      }
      return max_distance;
    }

    void main() {
      vec2 uv = ((2.0 * gl_FragCoord.xy) - resolution) / min(resolution.x, resolution.y);
      uv *= tan(radians(FOV) / 2.0);

      vec3 up = vec3(0.0, 1.0, 0.0);
      vec3 forward = vec3(0.0, 0.0, 1.0);
      vec3 right = cross(up, forward);

      vec3 ray_dir = normalize(up * uv.y + right * uv.x + forward);
      float d = raymarch(vec3(0, sin(t * 0.0008) * 0.8, -5. + (t * 0.0008)), ray_dir);

      if (d < max_distance) {
        float fog = 1.0 / (d / max_distance / 0.15);
        gl_FragColor = vec4(0.3, 0.6, 0.6, 1.0) * fog;
      } else {
        gl_FragColor = vec4(0, 0, 0, 1);
      }
    }
  </script>
  <script type="text/vert-shader" id="vert">
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position,0,1);
    }
  </script>
  <script>
    var can = document.querySelector('#board');
    can.width = window.innerWidth;
    can.height = window.innerHeight;

    var c = can.getContext('webgl',  { alpha: false });
    var w = c.drawingBufferWidth;
    var h = c.drawingBufferHeight;

    c.viewport(0, 0, w, h);
    c.clearColor(0, 0, 0, 1);
    c.clear(c.COLOR_BUFFER_BIT);

    c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA);
    c.enable(c.BLEND);

    var fragShader = c.createShader(c.FRAGMENT_SHADER);
    var vertShader = c.createShader(c.VERTEX_SHADER);

    c.shaderSource(fragShader, document.querySelector('#frag').textContent);
    c.shaderSource(vertShader, document.querySelector('#vert').textContent);

    c.compileShader(fragShader);
    if (!c.getShaderParameter(fragShader, c.COMPILE_STATUS)) {
      console.error("frag error:", c.getShaderInfoLog(fragShader));
    }
    c.compileShader(vertShader);
    if (!c.getShaderParameter(vertShader, c.COMPILE_STATUS)) {
      console.error("vert error:", c.getShaderInfoLog(vertShader));
    }

    var program = c.createProgram();
    c.attachShader(program, fragShader);
    c.attachShader(program, vertShader);
    c.linkProgram(program);
    if(!c.getProgramParameter(program, c.LINK_STATUS)) {
      console.error('Error linking program:', c.getProgramInfoLog(program))
    }
    c.useProgram(program);

    var res = c.getUniformLocation(program, 'resolution');
    c.uniform2f(res, w, h);
    var time = c.getUniformLocation(program, 't');
    c.uniform1f(time, 0);

    var buffer = c.createBuffer();
    c.bindBuffer(c.ARRAY_BUFFER, buffer);
    c.bufferData(c.ARRAY_BUFFER, new Float32Array([
      -1, 1, -1, -1, 1, 1,
      1, 1, -1, -1, 1, -1
    ]), c.STREAM_DRAW);
    c.enableVertexAttribArray(0);
    c.vertexAttribPointer(0, 2, c.FLOAT, false, 0, 0);

    function loop (t) {
      requestAnimationFrame(loop);

      c.clearColor(0, 0, 0, 1);
      c.clear(c.COLOR_BUFFER_BIT);

      c.uniform1f(time, t);
      c.drawArrays(c.TRIANGLES, 0, 6);
    }
    requestAnimationFrame(loop);

    //c.bindBuffer(c.ARRAY_BUFFER, null);
    //c.disableVertexAttribArray(0);
    //c.deleteBuffer(buffer);
  </script>
</body>
</html>